Para implementar a lógica de uma página com um ícone que muda a linguagem do site, você pode seguir os passos abaixo:

Criar um estado para a linguagem atual e uma função para alterar o estado:
jsx
Copy code
import React, { useState } from 'react';
// ... (seus imports)

export const Navbar = () => {
  // Estado para a linguagem atual
  const [language, setLanguage] = useState('en'); // Valor inicial 'en' para inglês

  // Função para mudar a linguagem
  const changeLanguage = (newLanguage) => {
    setLanguage(newLanguage);
    // Aqui você pode implementar lógica para atualizar a tradução do site com base na nova linguagem
  };

  // Resto do seu código...
}
Adicionar o ícone de mudança de linguagem e vincular a função para alterar a linguagem:
jsx
Copy code
import React, { useState } from 'react';
// ... (seus imports)

export const Navbar = () => {
  // ... (seu código)

  return (
    <div className='navbar'>
      <div className='wrapper'>
        <div className='left'>
          {/* Ícone para mudar a linguagem */}
          <div className='item' onClick={() => changeLanguage('en')}>
            <img src='../img/en.png' alt='' />
            <KeyboardArrowDownIcon />
          </div>
          <div className='item' onClick={() => changeLanguage('pt')}>
            <img src='../img/pt.png' alt='' />
            <KeyboardArrowDownIcon />
          </div>
          {/* Resto do seu código... */}
        </div>
        {/* Resto do seu código... */}
      </div>
    </div>
  );
}
Com a função changeLanguage, você pode atualizar o estado da linguagem (language) para a nova linguagem quando o ícone for 
clicado. Além disso, você pode implementar lógica para atualizar a tradução do site com base na nova linguagem. Isso pode envolver 
a troca de arquivos de tradução, re-renderização de componentes com base na nova linguagem, ou qualquer outra lógica específica da 
sua aplicação para gerenciar a mudança de idioma.
Lembrando que a implementação específica da lógica de mudança de linguagem dependerá da arquitetura e do fluxo de tradução do seu 
projeto. Portanto, é importante adaptar a lógica acima para se adequar ao seu caso de uso específico.

===================================================================================================================
------------------------------------------------------------------26/08/2023---------------------------------------
-------------------ESVAZIAR O CARRINHO APÓS O CHECKOUT--------------------------------------------------------------

Entendi a situação. Parece que você deseja realizar uma ação no frontend (mais especificamente, a chamada dispatch(resetCart()); 
para esvaziar o carrinho) a partir do backend (no arquivo order controller) após a confirmação do checkout.

No entanto, essa abordagem não é direta, pois o backend e o frontend são partes diferentes do seu aplicativo e geralmente não se 
comunicam diretamente dessa maneira.

A forma mais comum de realizar essa ação é fazer com que o frontend, após a confirmação bem-sucedida do checkout, realize uma nova 
chamada à sua API para notificar o backend que o pagamento foi processado com sucesso. Nessa chamada, você poderia executar a ação 
resetCart() no frontend e também, opcionalmente, poderia ter um endpoint específico no backend para esvaziar o carrinho.

Siga esses passos aproximados:

Frontend (após sucesso de checkout):
javascript
Copy code
// Após o redirecionamento bem-sucedido do Stripe
// Realize uma chamada à sua API para notificar o backend
const clearCart = async () => {
    try {
        // Realize uma chamada à API para esvaziar o carrinho
        await makeRequest.post("/clear-cart");
        
        // Execute a ação para resetar o carrinho localmente
        dispatch(resetCart());
    } catch (error) {
        console.log(error);
    }
};

// ... mais código ...

const handlePayment = async () => {
    try {
        const stripe = await stripePromise;

        const res = await makeRequest.post("/orders", {
            products,
        });

        await stripe.redirectToCheckout({
            sessionId: res.data.stripeSession.id,
        });

        // Chame a função para esvaziar o carrinho após o checkout
        clearCart();
    } catch (err) {
        console.log(err);
    }
};
Backend (adicionar um novo endpoint):
javascript
Copy code
// Adicione um novo endpoint à sua API que será chamado pelo frontend
module.exports = createCoreController("api::order.order", ({ strapi }) => ({
    // ... o código existente ...

    async clearCart(ctx) {
        try {
            // Coloque o código para esvaziar o carrinho aqui
            // Por exemplo, você pode usar o mesmo serviço utilizado em resetCart no frontend

            return { message: "Cart cleared successfully" };
        } catch (error) {
            ctx.response.status = 500;
            return { error };
        }
    },
}));
Certifique-se de que sua chamada à API esteja correta e que você esteja tratando as respostas e os erros apropriadamente. 
Lembre-se de que as operações de frontend e backend ocorrem de forma independente e é importante garantir que ações relevantes 
sejam comunicadas entre eles de maneira adequada.